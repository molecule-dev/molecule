/**
 * Docker Compose staging driver.
 *
 * Implements the `StagingDriver` interface using Docker Compose to manage
 * local ephemeral staging environments. Each branch gets isolated containers,
 * networking, and database volumes.
 *
 * @module
 */

import { exec } from 'node:child_process'
import { access, mkdir, readFile, rm, writeFile } from 'node:fs/promises'
import { join } from 'node:path'
import { promisify } from 'node:util'

import type {
  EnvironmentHealth,
  EnvironmentLogs,
  EnvironmentUrls,
  StagingDriver,
  StagingDriverConfig,
  StagingEnvironment,
} from '@molecule/api-staging'

import { generateComposeFile } from './compose-generator.js'
import {
  generateApiDockerfile,
  generateAppDockerfile,
  generateNginxConf,
} from './dockerfile-generator.js'

const execAsync = promisify(exec)

const STAGING_DIR = '.molecule/staging'

/**
 * Returns the compose file path for an environment.
 *
 * @param projectPath - Absolute project root path.
 * @param slug - Environment slug.
 * @returns Absolute path to the compose file.
 */
function composeFilePath(projectPath: string, slug: string): string {
  return join(projectPath, STAGING_DIR, `docker-compose.staging-${slug}.yml`)
}

/**
 * Returns the Docker Compose project name for an environment.
 *
 * @param slug - Environment slug.
 * @returns The project name.
 */
function projectName(slug: string): string {
  return `molecule-staging-${slug}`
}

/**
 * Runs a docker compose command for a staging environment.
 *
 * @param projectPath - Absolute project root path.
 * @param slug - Environment slug.
 * @param command - The docker compose subcommand (e.g. 'up -d', 'down').
 * @returns The command output.
 */
async function compose(
  projectPath: string,
  slug: string,
  command: string,
): Promise<{ stdout: string; stderr: string }> {
  const file = composeFilePath(projectPath, slug)
  return execAsync(`docker compose -f "${file}" -p "${projectName(slug)}" ${command}`, {
    cwd: projectPath,
  })
}

/**
 * Docker Compose staging driver implementation.
 */
export const provider: StagingDriver = {
  name: 'docker-compose',

  async checkPrerequisites(): Promise<{ met: boolean; missing: string[] }> {
    const missing: string[] = []

    try {
      await execAsync('docker --version')
    } catch {
      missing.push('docker')
    }

    try {
      await execAsync('docker compose version')
    } catch {
      missing.push('docker-compose')
    }

    return { met: missing.length === 0, missing }
  },

  async up(env: StagingEnvironment, config: StagingDriverConfig): Promise<EnvironmentUrls> {
    const stagingDir = join(config.projectPath, STAGING_DIR)
    await mkdir(stagingDir, { recursive: true })

    // Determine ports from environment driverMeta or use defaults
    const apiPort = (env.driverMeta?.apiPort as number) ?? 4001
    const appPort = (env.driverMeta?.appPort as number) ?? 5174
    const dbPort = (env.driverMeta?.dbPort as number) ?? 5433

    // Generate Dockerfiles and nginx config in .molecule/staging/
    await writeFile(join(stagingDir, 'Dockerfile.api'), generateApiDockerfile())
    await writeFile(
      join(stagingDir, 'Dockerfile.app'),
      generateAppDockerfile({ VITE_API_URL: `http://localhost:${apiPort}/api` }),
    )
    await writeFile(join(stagingDir, 'nginx.conf'), generateNginxConf())

    // Generate compose file (references the generated Dockerfiles)
    const composeContent = generateComposeFile(env, {
      apiPort,
      appPort,
      dbPort,
      dockerfilePath: stagingDir,
    })
    await writeFile(composeFilePath(config.projectPath, env.slug), composeContent)

    // Generate branch-specific .env file (API runtime vars only — Vite vars
    // are injected as Docker build args, not runtime env vars)
    const envContent = [
      `# Auto-generated by mlcl stage up`,
      `# Branch: ${env.branch}`,
      `# Slug: ${env.slug}`,
      `NODE_ENV=staging`,
      `PORT=${apiPort}`,
      `DATABASE_URL=postgresql://dev:dev@localhost:${dbPort}/molecule`,
      `STAGING_SLUG=${env.slug}`,
      `STAGING_BRANCH=${env.branch}`,
      '',
    ].join('\n')
    await writeFile(join(config.projectPath, `.env.staging.${env.slug}`), envContent)

    // Start containers
    await compose(config.projectPath, env.slug, 'up -d --build')

    return {
      api: `http://localhost:${apiPort}`,
      app: `http://localhost:${appPort}`,
    }
  },

  async down(env: StagingEnvironment, config: StagingDriverConfig): Promise<void> {
    try {
      await compose(config.projectPath, env.slug, 'down -v')
    } catch {
      // Containers may already be stopped — not an error
    }

    const stagingDir = join(config.projectPath, STAGING_DIR)

    // Clean up generated files (best-effort)
    const filesToRemove = [
      composeFilePath(config.projectPath, env.slug),
      join(config.projectPath, `.env.staging.${env.slug}`),
      join(stagingDir, 'Dockerfile.api'),
      join(stagingDir, 'Dockerfile.app'),
      join(stagingDir, 'nginx.conf'),
    ]

    for (const filePath of filesToRemove) {
      try {
        await rm(filePath)
      } catch {
        // File may not exist
      }
    }
  },

  async health(env: StagingEnvironment, config: StagingDriverConfig): Promise<EnvironmentHealth> {
    try {
      const { stdout } = await compose(config.projectPath, env.slug, 'ps --format json')

      // Parse container status
      const containers = stdout
        .trim()
        .split('\n')
        .filter(Boolean)
        .map((line) => {
          try {
            return JSON.parse(line) as { Service: string; State: string; Health: string }
          } catch {
            return null
          }
        })
        .filter(Boolean) as Array<{ Service: string; State: string; Health: string }>

      const apiContainer = containers.find((c) => c.Service === 'api')
      const appContainer = containers.find((c) => c.Service === 'app')

      const apiHealthy = apiContainer?.State === 'running'
      const appHealthy = appContainer?.State === 'running'

      return {
        healthy: apiHealthy && appHealthy,
        api: { status: apiContainer?.State ?? 'not found' },
        app: { status: appContainer?.State ?? 'not found' },
      }
    } catch {
      return {
        healthy: false,
        api: { status: 'unreachable' },
        app: { status: 'unreachable' },
      }
    }
  },

  async logs(
    env: StagingEnvironment,
    config: StagingDriverConfig,
    options?: { service?: 'api' | 'app' | 'all'; tail?: number; follow?: boolean },
  ): Promise<EnvironmentLogs> {
    const service = options?.service ?? 'all'
    const tail = options?.tail ?? 100
    const serviceArg = service === 'all' ? '' : ` ${service}`

    const { stdout } = await compose(
      config.projectPath,
      env.slug,
      `logs --tail ${tail}${serviceArg}`,
    )

    return {
      lines: stdout.split('\n').filter(Boolean),
      service,
    }
  },

  async list(config: StagingDriverConfig): Promise<StagingEnvironment[]> {
    const stagingDir = join(config.projectPath, STAGING_DIR)
    const { readdir } = await import('node:fs/promises')

    try {
      await access(stagingDir)
    } catch {
      return []
    }

    const files = await readdir(stagingDir)
    const composeFiles = files.filter(
      (f) => f.startsWith('docker-compose.staging-') && f.endsWith('.yml'),
    )

    const environments: StagingEnvironment[] = []
    for (const file of composeFiles) {
      const content = await readFile(join(stagingDir, file), 'utf-8')

      const branchMatch = content.match(/^# Branch: (.+)$/m)
      const slugMatch = content.match(/^# Slug: (.+)$/m)

      if (branchMatch && slugMatch) {
        environments.push({
          slug: slugMatch[1],
          branch: branchMatch[1],
          type: 'staging',
          name: `staging-${slugMatch[1]}`,
          createdAt: '',
          driver: 'docker-compose',
        })
      }
    }

    return environments
  },
}
