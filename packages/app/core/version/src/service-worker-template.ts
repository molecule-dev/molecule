/**
 * Service worker template for molecule.dev apps.
 *
 * Generates a service worker TypeScript source file that handles:
 * - Workbox precaching and app-shell routing
 * - Image caching with StaleWhileRevalidate
 * - Push notification display and click handling
 * - SKIP_WAITING and WINDOW_FOCUSED messages
 *
 * @module
 */

/**
 * Options for generating the service worker template.
 */
export interface ServiceWorkerTemplateOptions {
  /**
   * Whether to include push notification handlers.
   * @default false
   */
  pushNotifications?: boolean

  /**
   * Maximum number of cached images.
   * @default 50
   */
  maxImageCacheEntries?: number

  /**
   * Additional file extensions to cache (besides .png).
   * @default []
   */
  imageCacheExtensions?: string[]
}

/**
 * Generates a service worker TypeScript source file.
 *
 * @param options - Template configuration options.
 * @returns The service worker source code as a string.
 */
export function generateServiceWorkerTemplate(options: ServiceWorkerTemplateOptions = {}): string {
  const {
    pushNotifications = false,
    maxImageCacheEntries = 50,
    imageCacheExtensions = [],
  } = options

  const allImageExts = ['png', ...imageCacheExtensions]
  const imageMatch =
    allImageExts.length === 1
      ? `url.pathname.endsWith('.${allImageExts[0]}')`
      : `(/\\.(${allImageExts.join('|')})$/).test(url.pathname)`

  const parts: string[] = []

  // Header and imports
  parts.push(`/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import { clientsClaim } from 'workbox-core'
import { ExpirationPlugin } from 'workbox-expiration'
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { StaleWhileRevalidate } from 'workbox-strategies'

declare const self: ServiceWorkerGlobalScope

clientsClaim()

// Precache all assets generated by the build process.
// The __WB_MANIFEST variable is injected by the build tool.
precacheAndRoute(self.__WB_MANIFEST)

// App Shell-style routing: all navigation requests are fulfilled
// with index.html so client-side routing works offline.
const fileExtensionRegexp = new RegExp('/[^/?]+\\\\.[^/]+$')
registerRoute(
  ({ request, url }: { request: Request; url: URL }) => {
    if (request.mode !== 'navigate') return false
    if (url.pathname.startsWith('/_')) return false
    if (url.pathname.match(fileExtensionRegexp)) return false
    return true
  },
  createHandlerBoundToURL('/index.html'),
)

// Cache images with a StaleWhileRevalidate strategy.
registerRoute(
  ({ url }) => url.origin === self.location.origin && ${imageMatch},
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [new ExpirationPlugin({ maxEntries: ${maxImageCacheEntries} })],
  }),
)`)

  // Push notification handlers (conditional)
  if (pushNotifications) {
    parts.push(`

/** Displays a push notification using the service worker registration. */
const showNotification = async (notification: {
  title: string
  options: NotificationOptions
}) => {
  return self.registration.showNotification(
    notification.title,
    notification.options,
  )
}

/** Closes all active notifications for this service worker. */
const removeNotifications = async () => {
  const notifications = await self.registration.getNotifications()
  for (const notification of notifications) {
    notification.close()
  }
}

/** Returns the currently focused client window, or null if none is focused. */
const getFocusedClient = async () => {
  const allClients = await self.clients.matchAll({ type: 'window' })
  for (const client of allClients) {
    if (client.focused) return client
  }
  return null
}

/** Focuses an existing client window or opens a new one at '/'. */
const focusWindow = async () => {
  const allClients = await self.clients.matchAll({ type: 'window' })

  if (allClients.length > 0) {
    allClients[0].focus()
  } else {
    const client = await self.clients.openWindow('/')
    client?.focus()
  }
}

// Close the notification and focus a window when clicked.
self.onnotificationclick = (event: NotificationEvent) => {
  event.notification.close()
  event.waitUntil(focusWindow())
}

// Show a notification when a push event is received.
self.addEventListener('push', (event) => {
  try {
    const data = event.data?.json()
    const { title, ...options } = data

    if (title) {
      event.waitUntil(showNotification({ title, options }))
    }
  } catch (error) {
    console.error('Push notification error:', error)
  }
})`)
  }

  // Message handlers (always included)
  const messageHandlers = pushNotifications
    ? `
    case 'WINDOW_FOCUSED':
      return event.waitUntil(removeNotifications())`
    : ''

  parts.push(`

// Listen for messages from the application.
self.addEventListener('message', (event) => {
  switch (event.data?.type) {
    case 'SKIP_WAITING':
      return event.waitUntil(self.skipWaiting())${messageHandlers}
    default:
      return
  }
})
`)

  return parts.join('')
}
